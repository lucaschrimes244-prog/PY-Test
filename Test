import maya.cmds as cmds
import maya.OpenMayaUI as omui
import sys
import os
import importlib

# --- Robust PySide2/Shiboken2 Imports ---
# This structure is critical for running correctly in Maya's environment
try:
    from PySide2 import QtWidgets, QtCore, QtGui
    from shiboken2 import wrapInstance
except ImportError:
    try:
        from PySide6 import QtWidgets, QtCore, QtGui
        from shiboken6 import wrapInstance
    except ImportError:
        # Fallback/Error handling
        raise ImportError("Could not load PySide2 or PySide6/Shiboken. Is Qt installed correctly?")

# --- Global Reference for Singleton and ScriptJob Access ---
# This prevents the window from being garbage collected and provides a stable
# reference for the scriptJob command string.
SMARTSHEET_WINDOW = None

# --- Utility Functions ---

def get_maya_main_window():
    """Returns the Maya main window as a QWidget pointer."""
    # MQtUtil.mainWindow() returns a pointer to the main Maya window (a QWidget)
    maya_ptr = omui.MQtUtil.mainWindow()
    
    if maya_ptr is not None:
        # Use int() for the pointer address, which works in Python 3 (Maya 2022+)
        # If using older Python 2 Maya (e.g., Maya 2016), you might need:
        # return wrapInstance(long(maya_ptr), QtWidgets.QWidget)
        return wrapInstance(int(maya_ptr), QtWidgets.QWidget)
    return None

def delete_ui(ui_name):
    """Deletes any existing instance of the UI to avoid duplicates."""
    if cmds.window(ui_name, exists=True):
        cmds.deleteUI(ui_name, window=True)
    elif cmds.windowPref(ui_name, exists=True):
        cmds.windowPref(ui_name, remove=True)

# --- Main UI Class ---

class SmartSheetUI(QtWidgets.QMainWindow):
    """
    A tool that displays attributes of selected objects in a dynamic table.
    It automatically updates when the selection changes using a scriptJob.
    """
    
    WINDOW_TITLE = "Smart Attribute Sheet"
    UI_OBJECT_NAME = "SmartSheetUI_Window"
    
    def __init__(self, parent=get_maya_main_window()):
        # Ensure only one instance exists
        global SMARTSHEET_WINDOW
        if SMARTSHEET_WINDOW:
            SMARTSHEET_WINDOW.close()
            
        super(SmartSheetUI, self).__init__(parent)
        
        self.setWindowTitle(self.WINDOW_TITLE)
        self.setObjectName(self.UI_OBJECT_NAME)
        self.script_job_num = None # Store the job ID for cleanup
        
        self.create_widgets()
        self.setup_layout()
        self.install_script_job()
        
        # Initial data load
        self.refresh_ui()

    def create_widgets(self):
        """Initializes all custom widgets."""
        self.central_widget = QtWidgets.QWidget()
        self.setCentralWidget(self.central_widget)
        
        # The main display area for attributes
        self.table = QtWidgets.QTableWidget()
        self.table.setEditTriggers(QtWidgets.QAbstractItemView.DoubleClicked)
        self.table.setAlternatingRowColors(True)
        self.table.setStyleSheet("""
            QTableWidget {
                border: 1px solid #333;
                selection-background-color: #555;
            }
            QHeaderView::section {
                background-color: #383838;
                color: #DDD;
                padding: 4px;
                border: 1px solid #222;
                border-bottom: 2px solid #555;
            }
            QTableWidget::item {
                padding: 4px;
            }
        """)
        
        # Connect table changes to the Maya scene update function
        self.table.cellChanged.connect(self.handle_cell_changed)
        
    def setup_layout(self):
        """Arranges widgets into the main layout."""
        main_layout = QtWidgets.QVBoxLayout(self.central_widget)
        main_layout.addWidget(self.table)
        
        # Set a reasonable default size
        self.resize(800, 400)

    def install_script_job(self):
        """
        Creates a Maya scriptJob to automatically call refresh_ui when the selection changes.
        This uses the global reference to ensure the command is stable, even after reloads.
        """
        # Ensure any old job is killed first if we're reloading
        if self.script_job_num:
            cmds.scriptJob(kill=self.script_job_num, force=True)

        # The command must be a string that Python can evaluate in the Maya runtime.
        # It calls the refresh_ui method on the currently loaded instance of the tool.
        script_job_command = f"smart_sheet.SMARTSHEET_WINDOW.refresh_ui()"
        
        try:
            # -event "SelectionChanged": Triggered whenever object selection changes.
            # -parent: Ties the script job lifecycle to the UI object name for cleanup.
            self.script_job_num = cmds.scriptJob(
                event=["SelectionChanged", script_job_command],
                parent=self.UI_OBJECT_NAME,
                runOnce=False
            )
            print(f"ScriptJob installed successfully. ID: {self.script_job_num}")
            
        except Exception as e:
            print(f"Error installing scriptJob: {e}")

    def refresh_ui(self):
        """Fetches current data and updates the QTableWidget."""
        try:
            node_names, attr_names, data_rows = self.get_selected_data()
            self.populate_table(node_names, attr_names, data_rows)
            
        except Exception as e:
            # Critical error handling for the refresh logic
            print(f"Failed to refresh UI: {e}")

    def get_selected_data(self):
        """
        Queries Maya for the selected objects and their attributes.
        Returns: (node_names list, attr_names list, data_rows list of lists)
        """
        node_names = cmds.ls(selection=True, type='transform', long=True)
        
        if not node_names:
            return [], [], [] # Nothing selected, return empty data

        # Get the union of all keyable attributes from all selected nodes
        all_keyable_attrs = set()
        for node in node_names:
            try:
                # Filter for keyable attributes only (e.g., tx, ty, tz, rx, etc.)
                attrs = cmds.listAttr(node, keyable=True, multi=True, scalar=True) or []
                all_keyable_attrs.update(attrs)
            except Exception:
                # Ignore nodes that don't support listAttr (e.g., cameras/shapes without keyable attrs)
                continue 

        attr_names = sorted(list(all_keyable_attrs))
        
        # Prepare the data matrix: one row per object
        data_rows = []
        for node in node_names:
            row_data = []
            for attr in attr_names:
                full_attr = f"{node}.{attr}"
                try:
                    # Get the current value
                    value = cmds.getAttr(full_attr)
                    # Formatting values: listAttr(multi=True) handles compound attributes.
                    # Simple attrs are usually single floats/ints/strings.
                    row_data.append(str(value) if isinstance(value, (int, float, str)) else '...') 
                except RuntimeError:
                    # Attribute not present on this specific object (e.g., Cube has a custom attr, Sphere doesn't)
                    row_data.append("-") 
                except Exception:
                    # General error getting attribute
                    row_data.append("ERROR") 

            data_rows.append(row_data)
            
        return node_names, attr_names, data_rows

    def populate_table(self, node_names, attr_names, data_rows):
        """Populates the QTableWidget with the data."""
        self.table.blockSignals(True) # Block signals during table update to prevent handle_cell_changed from firing

        self.table.setRowCount(len(node_names))
        
        # Headers: Node Names (Row Header) and Attribute Names (Column Header)
        self.table.setColumnCount(len(attr_names))
        self.table.setHorizontalHeaderLabels(attr_names)
        self.table.setVerticalHeaderLabels([os.path.basename(n) for n in node_names]) # Use short name for row header
        
        # Fill the data
        for row, data in enumerate(data_rows):
            for col, value in enumerate(data):
                item = QtWidgets.QTableWidgetItem(value)
                
                # Center-align the text for better readability
                item.setTextAlignment(QtCore.Qt.AlignCenter)
                
                # Attributes that cannot be set (e.g., "-") should not be editable
                if value == "-":
                    item.setFlags(item.flags() & ~QtCore.Qt.ItemIsEditable)

                self.table.setItem(row, col, item)
        
        # Resize columns to fit content
        self.table.resizeColumnsToContents()
        self.table.blockSignals(False) # Re-enable signals

    def handle_cell_changed(self, row, column):
        """Updates the Maya scene when a cell is edited in the table."""
        node_names = [n for n in self.table.verticalHeaderLabels()]
        
        # Ensure we don't try to set values if the list is empty
        if not node_names:
            return

        try:
            # 1. Get the target node name (using the long path from get_selected_data is safer, 
            # but for a quick script, the short name works if not ambiguous)
            # Since we used long names to generate data, let's re-query the long name
            node_long_name = cmds.ls(self.table.verticalHeaderItem(row).text(), long=True)[0]
            
            # 2. Get the attribute name
            attr_name = self.table.horizontalHeaderItem(column).text()
            
            # 3. Get the new value from the cell
            new_value_text = self.table.item(row, column).text()

            # 4. Attempt to convert and set the attribute
            full_attr = f"{node_long_name}.{attr_name}"
            
            # Check the attribute type (assuming most keyable attrs are floats/ints)
            try:
                # Try setting as float first
                cmds.setAttr(full_attr, float(new_value_text))
            except ValueError:
                # If float fails, try setting as string
                cmds.setAttr(full_attr, new_value_text, type="string")
            except Exception as e:
                print(f"Could not set attribute {full_attr}: {e}")
                
        except Exception as e:
            print(f"Error handling cell change: {e}")


    def closeEvent(self, event):
        """Custom close event to clean up the script job."""
        
        # CRITICAL: Kill the persistent script job when the window closes
        if self.script_job_num:
            try:
                cmds.scriptJob(kill=self.script_job_num, force=True)
                print(f"Killed script job ID: {self.script_job_num}")
            except Exception as e:
                print(f"Warning: Could not kill script job {self.script_job_num}: {e}")
                
        # Clean up the global reference
        global SMARTSHEET_WINDOW
        SMARTSHEET_WINDOW = None
        
        super(SmartSheetUI, self).closeEvent(event)

# --- Entry Point Function ---

def run():
    """
    Main function to run the tool. Handles singleton check.
    """
    
    # 1. Delete old UI instances
    delete_ui(SmartSheetUI.UI_OBJECT_NAME)
    
    # 2. Create the new instance
    window = SmartSheetUI()
    
    # 3. Store the instance globally
    global SMARTSHEET_WINDOW
    SMARTSHEET_WINDOW = window
    
    # 4. Show the window
    window.show()
    window.raise_()
    
if __name__ == '__main__':
    # Allows testing the run() function directly if script is sourced
    run()
